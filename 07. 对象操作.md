# 7. 对象操作

本章介绍了 *Chez Scheme* 中针对非数值对象的特定操作，包括 pairs, numbers 等标准对象，以及 boxes, records 等 *Chez Scheme* 扩展对象。第 8 章介绍了针对数字的操作。关于对象的标准操作的更多描述，参见“The Scheme Programming Language，第 4 版”的第 6 章，或 Scheme 第 6 修订版的报告。


### 7.1. R6RS 中缺少的类型判断

过程: (enum-set? obj)

返回: 如果 `obj` 为 `enum set` 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

此一谓词应当被定义，但缺失于第 6 修订版中。

过程: (record-constructor-descriptor? obj)

返回: 如果 `obj` 为 `record constructor` 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

此一谓词应当被定义，但缺失于第 6 修订版中。


### 7.2. 点对和列表 (Pair and List)

过程: (atom? obj)

返回: 如果 `obj` 不是点对，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

atom? 等价于 (lambda (x) (not (pair? x))).

    (atom? '(a b c)) => #f
    (atom? '(3 . 4)) => #f
    (atom? '()) => #t
    (atom? 3) => #t

过程: (list-head list n)

返回: 列表前 n 个元素的列表

库: (chezscheme)

n 须为一精确非负整数，且小于或等于列表的长度。

`list-head` 可以和另一个 Scheme 标准过程 `list-tail` 配合，用于将一个列表分割成两个单独的列表。不过， `list-tail`
并不进行空间分配，只是返回原列表的子列表，而 `list-head` 则总是返回原列表前面部分的一份拷贝。

`list-head` 可依如下定义：

    (define list-head
      (lambda (ls n)
        (if (= n 0)
            '()
            (cons (car ls) (list-head (cdr ls) (- n 1))))))

    (list-head '(a b c) 0) => ()
    (list-head '(a b c) 2) => (a b)
    (list-head '(a b c) 3) => (a b c)
    (list-head '(a b c . d) 2) => (a b)
    (list-head '(a b c . d) 3) => (a b c)
    (list-head '#1=(a . #1#) 5) => (a a a a a)

过程: (last-pair list)

返回: 列表的最后一个点对

库: (chezscheme)

列表不可为空。 `last-pair` 返回列表的最后一个点对（不是最后一个元素）。列表可以是一个不严格的列表（improper list），此时，最后一个点对为一个包含最末元素和结束对象的点对。

    (last-pair '(a b c d)) => (d)
    (last-pair '(a b c . d)) => (c . d)

过程: (list-copy list)

返回: 列表的一份拷贝

库: (chezscheme)

`list-copy` 返回与列表相等( `equal?` )的一个列表，使用新的点对重新构成顶层的列表结构。

    (list-copy '(a b c)) => (a b c)

    (let ([ls '(a b c)])
      (equal? ls (list-copy ls))) => #t

    (let ([ls '(a b c)])
      (let ([ls-copy (list-copy ls)])
        (or (eq? ls-copy ls)
            (eq? (cdr ls-copy) (cdr ls))
            (eq? (cddr ls-copy) (cddr ls))))) => #f

过程: (list\* obj &#x2026; final-obj)

返回: 由 `obj ...` 组成的列表，结束于 `final-obj`

库: (chezscheme)

`list*` 和第 6 修订版中的 `cons*` 是一样的。

过程: (make-list n)

过程: (make-list n obj)

返回: n 个对象的列表

库: (chezscheme)

n 须为非负整数。如果省略 obj，则列表的元素为未指定的。

    (make-list 0 '()) => ()
    (make-list 3 0) => (0 0 0)
    (make-list 2 "hi") => ("hi" "hi")

过程: (iota n)

返回: 从 0（包含）到 n（不包含）的整数列表

库: (chezscheme)

n 须为精确的非负整数。

    (iota 0) => ()
    (iota 5) => (0 1 2 3 4)

过程: (enumerate ls)

返回: 从 0（包含）到长度 ls（不包含）的整数列表。

库: (chezscheme)

    (enumerate '()) => ()
    (enumerate '(a b c)) => (0 1 2)
    (let ([ls '(a b c)])
      (map cons ls (enumerate ls))) => ((a . 0) (b . 1) (c . 2))

过程: (remq! obj list)

过程: (remv! obj list)

过程: (remove! obj list)

返回: 列表中所有 `obj` 都被移除后的列表

库: (chezscheme)

这些过程与第 6 修订版中的 `remq`, `remv`, 及 `remove` 过程类似，只是 `remq!`, `remv!` 和 `remove!` 使用输入列表中的点对来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。

    (remq! 'a '(a b a c a d)) => (b c d)
    (remv! #\a '(#\a #\b #\c)) => (#\b #\c)
    (remove! '(c) '((a) (b) (c))) => ((a) (b))

过程: (substq new old tree)

过程: (substv new old tree)

过程: (subst new old tree)

过程: (substq! new old tree)

过程: (substv! new old tree)

过程: (subst! new old tree)

返回: old 被替换为 new 后的树

库: (chezscheme)

这些过程遍历树，以对象 new 替换树中所有与对象 old 相等的对象。

对于 `substq` 和 `substq!` ，相等性测试是基于 `eq?` , `substv` 和 `substv!` 是基于 `eqv?`, 而 `subst` 和 `subst!` 是基于 `equal?`.

`substq!`, `substv!`, 和 `subst!` 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。

    (substq 'a 'b '((b c) b a)) => ((a c) a a)

    (substv 2 1 '((1 . 2) (1 . 4) . 1)) => ((2 . 2) (2 . 4) . 2)

    (subst 'a
           '(a . b)
           '((a . b) (c a . b) . c)) => (a (c . a) . c)

    (let ([tr '((b c) b a)])
      (substq! 'a 'b tr)
      tr) => ((a c) a a)

过程: (reverse! list)

返回: 对原列表反向排序的列表

库: (chezscheme)

`reverse!` 通过反转其链接破坏性地反向排序列表。以 `reverse!` 取代 `reverse` 减少了空间分配，但并不一定比使用 `reverse` 更快。如果滥用，会很容易导致混乱或错误的结果。

    (reverse! '()) => ()
    (reverse! '(a b c)) => (c b a)

    (let ([x '(a b c)])
      (reverse! x)
      x) => (a)

    (let ([x '(a b c)])
      (set! x (reverse! x))
      x) => (c b a)

过程: (append! list &#x2026;)

返回: 输入列表的串联

库: (chezscheme)

如同 `append`, `append!` 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， `append!` 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个 `cdr`, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。

相比于 `append`, `append!` 进行更少的空间分配，但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。

    (append! '(a b) '(c d)) => (a b c d)

    (let ([x '(a b)])
      (append! x '(c d))
      x) => (a b c d)


### 7.3. 字符 (Characters)

*Chez Scheme* 以两种方式扩展了字符的句法。其一，前缀 `#\` 后面紧跟 3 位八进制数字会被读取为一个字符，其数字编码即为此 3 位数的八进制值，例如， `#\044` 被读取为 `#\$`. 其二，它可以识别若干非标准命名的字符： `#\rubout` (等同于 `#\delete`)， `#\bel` (等同于 `#\alarm`), `#\vt` (等同于 `#\vtab`), `#\nel` (Unicode NEL 字符), 以及 `#\ls` (Unicode LS 字符). 非标准字符的名字可以通过过程 `char-name` 更改（参见 9.14 节）。

读取器若遇到 `#!r6rs` ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 `#!chezscheme`.

过程: (char=? char1 char2 &#x2026;)

过程: (char<? char1 char2 &#x2026;)

过程: (char>? char1 char2 &#x2026;)

过程: (char<=? char1 char2 &#x2026;)

过程: (char>=? char1 char2 &#x2026;)

过程: (char-ci=? char1 char2 &#x2026;)

过程: (char-ci<? char1 char2 &#x2026;)

过程: (char-ci>? char1 char2 &#x2026;)

过程: (char-ci<=? char1 char2 &#x2026;)

过程: (char-ci>=? char1 char2 &#x2026;)

返回: 如果关系成立，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

这些谓词与第 6 修订版中的对应版本是一样的，只是被扩展为接受一个以上参数，而非两个以上参数。当只传入一个参数时，这些谓词均返回 `#t`.

    (char>? #\a) => #t
    (char<? #\a) => #t
    (char-ci=? #\a) => #t

过程: (char- char1 char2)

返回: `char1` 和 `char2` 间的整数差值

库: (chezscheme)

`char-` 以 `char1` 的整数值减去 `char2` 的整数值，并返回差值。后面的例子假设以字符的 ASCII 码作为其整数表示。

    (char- #\f #\e) => 1

    (define digit-value
      ; 根据基数 r 返回数字 c 的值，
      ; 如果 c 不是有效的数字，则返回 #f
      (lambda (c r)
        (let ([v (cond
                  [(char<=? #\0 c #\9) (char- c #\0)]
                  [(char<=? #\A c #\Z) (char- c #\7)]
                  [(char<=? #\a c #\z) (char- c #\W)]
                  [else 36])])
          (and (fx< v r) v))))
    (digit-value #\8 10) => 8
    (digit-value #\z 10) => #f
    (digit-value #\z 36) => 35

`char-` 可依如下定义。

    (define char-
      (lambda (c1 c2)
        (- (char->integer c1) (char->integer c2))))


### 7.4. 字符串 (Strings)

基于标准的字符串句法， *Chez Scheme* 增加了两种转义字符： `\'` 生成单引号字符，以及 `\nnn`, 即，反斜杠紧跟着 3 位 8 进制数，生成等同于此 3 位 8 进制数的值的字符。读取器若遇到 `#!r6rs` ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 `#!chezscheme`.

所有字符串默认是可变的，包括常量。程序可以通过 `string->immutable-string` 创建不可变字符串。尝试修改不可变字符串会导致抛出异常。

在 *Chez Scheme* 中，字符串的长度和索引总是定长数。

过程: (string=? string1 string2 string3 &#x2026;)

过程: (string<? string1 string2 string3 &#x2026;)

过程: (string>? string1 string2 string3 &#x2026;)

过程: (string<=? string1 string2 string3 &#x2026;)

过程: (string>=? string1 string2 string3 &#x2026;)

过程: (string-ci=? string1 string2 string3 &#x2026;)

过程: (string-ci<? string1 string2 string3 &#x2026;)

过程: (string-ci>? string1 string2 string3 &#x2026;)

过程: (string-ci<=? string1 string2 string3 &#x2026;)

过程: (string-ci>=? string1 string2 string3 &#x2026;)

返回: 如果关系成立，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

这些谓词与第 6 修订版中的对应版本是一样的，只是被扩展为接受一个以上参数，而非两个以上参数。当只传入一个参数时，这些谓词均返回 `#t`.

    (string>? "a") => #t
    (string<? "a") => #t
    (string-ci=? "a") => #t

过程: (string-copy! src src-start dst dst-start n)

返回: 未定义

库: (chezscheme)

`src` 和 `dst` 必须是字符串，且 `dst` 必须可变。 `src-start`, `dst-start`, 以及 `n` 必须是精确的非负整数。 `src-start` 和 `n` 的和绝对不能超过 `src` 的长度， 而 `dst-start` 和 `n` 的和则一定不能超过 `dst` 的长度。

`string-copy!` 以 `src` 中起始于 `src-start` ，长度为 `n` 字节的部分，覆盖 `dst` 中起始于 `dst-start` ，长度为 `n` 字节的部分。即使 `dst` 和 `src` 是同一个字符串，且源和目标位置相互重叠，这个操作也能生效。即，在操作开始时，目标位置先被源字符串中的字符填充。

    (define s1 "to boldly go")
    (define s2 (make-string 10 #\-))

    (string-copy! s1 3 s2 1 3)
    s2 => "-bol------"

    (string-copy! s1 7 s2 4 2)
    s2 => "-bolly----"

    (string-copy! s2 2 s2 5 4)
    s2 => "-bollolly-"

过程: (substring-fill! string start end char)

返回: 未定义

库: (chezscheme)

`string` 必须是可变的。 `string` 于 `start` (包含) 和 `end` (不包含) 之间的字符均被设置为 `char`. `start` 和 `end` 必须是非负整数； `start` 必须严格小于 `string` 的长度，而 `end` 可以小于或等于 `string` 的长度。如果 `end ≤ start`, 则字符串保持不变。

    (let ([str (string-copy "a tpyo typo")])
      (substring-fill! str 2 6 #\X)
      str) => "a XXXX typo"

过程: (string-truncate! string n)

返回: 字符串或空字符串

库: (chezscheme)

`string` 必须是可变的。 `n` 必须是精确的非负定长数，且不大于 `string` 的长度。如果 `n` 是 0, `string-truncate!` 返回空字符串。否则， `string-truncate!` 破坏性地把 `string` 缩短为其前 `n` 个字符，并返回 `string`.

    (define s (make-string 7 #\$))
    (string-truncate! s 0) => ""
    s => "$$$$$$$"
    (string-truncate! s 3) => "$$$"
    s => "$$$"

过程: (mutable-string? obj)

返回: 如果 `obj` 是可变字符串，则为 `#t`, 否则为 `#f`.

过程: (immutable-string? obj)

返回: 如果 `obj` 是不可变字符串，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (mutable-string? (string #\a #\b #\c)) => #t
    (mutable-string? (string->immutable-string "abc")) => #f
    (immutable-string? (string #\a #\b #\c)) => #f
    (immutable-string? (string->immutable-string "abc")) => #t
    (immutable-string? (cons 3 4)) => #f

过程: (string->immutable-string string)

返回: 与 `string` 相等(equal)的不可变字符串

库: (chezscheme)

如果 `string` 是不可变字符串，则结果为其本身；否则，结果是个不可变字符串，其内容与 `string` 相同。

    (define s (string->immutable-string (string #\x #\y #\z)))
    (string-set! s 0 #\a) => exception: not mutable


### 7.5. 向量 (Vectors)

*Chez Scheme* 扩展了向量的句法，以允许在 `#` 和左括号之间指定向量的长度，形如， `#3(a b c)`. 如果在此语法形式下提供的向量元素比指定的长度要少，则之后的每个元素都与最后一个提供的元素相同。读取器若遇到 `#!r6rs` ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 `#!chezscheme`.

在 *Chez Scheme* 中，向量的长度和索引总是定长数。

所有向量默认都是可变的，包括常量。程序可以通过 `vector->immutable-vector` 创建不可变向量。尝试修改不可变向量会导致抛出异常。

过程: (vector-copy vector)

返回: `vector` 的一份拷贝

库: (chezscheme)

`vector-copy` 生成一个长度和内容都和 `vector` 相同的新向量。里面的元素本身不是被复制的。

    (vector-copy '#(a b c)) => #(a b c)

    (let ([v '#(a b c)])
      (eq? v (vector-copy v))) => #f

过程: (vector-set-fixnum! vector n fixnum)

返回: 未定义

库: (chezscheme)

`vector` 必须是不可变的。 `vector-set-fixnum!` 把向量的第 `n` 个元素变更为 `fixnum`. `n` 必须是一个确切的非负整数，且严格小于 `vector` 的长度。

储存定长数要比储存任意值快，因为对于任意值，系统需要记录从老到新的各个对象的潜在分配，以支持分代垃圾回收。不过，必须小心确保参数确实是一个定长数；否则，收集器可能无法正确地追踪资源分配。只要不在优化级别 3, 基本过程会对参数进行定长数检验。

参见后面关于全定长数向量 （fxvectors) 的描述。

    (let ([v (vector 1 2 3 4 5)])
      (vector-set-fixnum! v 2 73)
      v) => #(1 2 73 4 5)

过程: (vector-cas! vector n old-obj new-obj)

返回: 如果 `vector` 有改变，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

`vector` 必须是可变的。 若 `vector` 的第 `n` 个元素和 `old-obj` 相同（ `eq?` ）, 则 `vector-cas!` 自动将此元素替换为 `new-obj`, 若不相同，则 `vector` 保持不变。

    (define v (vector 'old0 'old1 'old2))
    (vector-cas! v 1 'old1 'new1) => #t
    (vector-ref v 1) => 'new1
    (vector-cas! v 2 'old1 'new2) => #f
    (vector-ref v 2) => 'old2

过程: (mutable-vector? obj)

返回: 如果 `obj` 是可变向量，则为 `#t`, 否则为 `#f`.

过程: (immutable-vector? obj)

返回: 如果 `obj` 是不可变向量，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (mutable-vector? (vector 1 2 3)) => #t
    (mutable-vector? (vector->immutable-vector (vector 1 2 3))) => #f
    (immutable-vector? (vector 1 2 3)) => #f
    (immutable-vector? (vector->immutable-vector (vector 1 2 3))) => #t
    (immutable-vector? (cons 3 4)) => #f

过程: (vector->immutable-vector vector)

返回: 与 `vector` 相等(equal)的一个不可变向量

库: (chezscheme)

如果 `vector` 是不可变向量，则结果为其本身；否则，结果是与 `vector` 内容相同的一个不可变向量。

    (define v (vector->immutable-vector (vector 1 2 3)))
    (vector-set! v 0 0) => exception: not mutable


### 7.6. 定长数向量 (Fixnum-Only Vectors)

定长数向量, 即 "fxvectors", 类似于向量，但只包含定长数。定长数向量的输出形式以前缀 `#vfx` 替换向量的前缀 `#`, 例如， `#vfx(1 2 3)` 或 `#10vfx(2)`. 读取器若遇到 `#!r6rs` ，则会在其后的输入流中禁用定长数向量的句法，除非在更近的位置遇到 `#!chezscheme`.

定长数向量的长度和索引总是定长数。

更新定长数向量通常比更新向量节省资源，因为对于向量来说，系统需要记录从老到新的各个对象的潜在分配，以支持分代垃圾回收。定长数向量不包含要指向内存某一区域的指针，受益于此，存储管理系统不需要在垃圾收集期间对这些指针进行追踪。

定长数向量默认是可变的，包括常量。程序可以通过 `fxvector->immutable-fxvector` 创建不可变的定长数向量。尝试修改一个不可变的定长数向量会导致异常抛出。

可参考前述的 `vector-set-fixnum!`.

过程: (fxvector? obj)

返回: 如果 `obj` 是一个定长数向量，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (fxvector? #vfx()) => #t
    (fxvector? #vfx(1 2 3)) => #t
    (fxvector? (fxvector 1 2 3)) => #t
    (fxvector? '#(a b c)) => #f
    (fxvector? '(a b c)) => #f
    (fxvector? "abc") => #f

过程: (fxvector fixnum &#x2026;)

返回: 一个由参数中的所有定长数 `fixnum ...` 组成的定长数向量

库: (chezscheme)

    (fxvector) => #vfx()
    (fxvector 1 3 5) => #vfx(1 3 5)

过程: (make-fxvector n)

过程: (make-fxvector n fixnum)

返回: 一个长度为 `n` 的定长数向量

库: (chezscheme)

`n` 必须是定长数。如果有提供参数 `fixnum`, 则定长数向量中的每个元素都被初始化为 `fixnum`; 不然，其中元素则均为未定义。

    (make-fxvector 0) => #vfx()
    (make-fxvector 0 7) => #vfx()
    (make-fxvector 5 7) => #vfx(7 7 7 7 7)

过程: (fxvector-length fxvector)

返回: `fxvector` 中的元素个数

库: (chezscheme)

    (fxvector-length #vfx()) => 0
    (fxvector-length #vfx(1 2 3)) => 3
    (fxvector-length #10vfx(1 2 3)) => 10
    (fxvector-length (fxvector 1 2 3 4)) => 4
    (fxvector-length (make-fxvector 300)) => 300

过程: (fxvector-ref fxvector n)

返回: `fxvector` 中的第 `n` 个元素 (索引基于 0)

库: (chezscheme)

`n` 必须是一个非负定长数，且严格小于 `fxvector` 的长度。

    (fxvector-ref #vfx(-1 2 4 7) 0) => -1
    (fxvector-ref #vfx(-1 2 4 7) 1) => 2
    (fxvector-ref #vfx(-1 2 4 7) 3) => 7

过程: (fxvector-set! fxvector n fixnum)

返回: 未定义

库: (chezscheme)

`fxvector` 必须是可变的。 `n` 必须是一个非负定长数，且严格小于 `fxvector` 的长度。 `fxvector-set!` 把 `fxvector` 中的第 `n` 个元素修改为 `fixnum`.

    (let ([v (fxvector 1 2 3 4 5)])
      (fxvector-set! v 2 (fx- (fxvector-ref v 2)))
      v) => #vfx(1 2 -3 4 5)

过程: (fxvector-fill! fxvector fixnum)

返回: 未定义

库: (chezscheme)

`fxvector` 必须是可变的。 `fxvector-fill!` 把 `fxvector` 中的每个元素替换为 `fixnum`.

    (let ([v (fxvector 1 2 3)])
      (fxvector-fill! v 0)
      v) => #vfx(0 0 0)

过程: (fxvector->list fxvector)

返回: `fxvector` 中所有元素组成的列表

库: (chezscheme)

    (fxvector->list (fxvector)) => ()
    (fxvector->list #vfx(7 5 2)) => (7 5 2)

    (let ([v #vfx(1 2 3 4 5)])
      (apply fx* (fxvector->list v))) => 120

过程: (list->fxvector list)

返回: `list` 中所有元素组成的定长数向量

库: (chezscheme)

`list` 必须完全由定长数组成。

    (list->fxvector '()) => #vfx()
    (list->fxvector '(3 5 7)) => #vfx(3 5 7)

    (let ([v #vfx(1 2 3 4 5)])
      (let ([ls (fxvector->list v)])
        (list->fxvector (map fx* ls ls)))) => #vfx(1 4 9 16 25)

过程: (fxvector-copy fxvector)

返回: `fxvector` 的一份拷贝

库: (chezscheme)

`fxvector-copy` 生成一个与 `fxvector` 长度和内容都一样的新的定长数向量。

    (fxvector-copy #vfx(3 4 5)) => #vfx(3 4 5)

    (let ([v #vfx(3 4 5)])
      (eq? v (fxvector-copy v))) => #f

过程: (mutable-fxvector? obj)

返回: 如果 `obj` 是一个可变的定长数向量，则为 `#t`, 否则为 `#f`.

过程: (immutable-fxvector? obj)

返回: 如果 `obj` 是一个不可变的定长数向量，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (mutable-fxvector? (fxvector 1 2 3)) => #t
    (mutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) => #f
    (immutable-fxvector? (fxvector 1 2 3)) => #f
    (immutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) => #t
    (immutable-fxvector? (cons 3 4)) => #f

过程: (fxvector->immutable-fxvector fxvector)

返回: `fxvector` 的一份不可变的拷贝或其自身

库: (chezscheme)

如果 `fxvector` 是不可变的，则结果为其本身；否则，结果是与 `fxvector` 内容相同的一个不可变定长数向量。

    (define v (fxvector->immutable-fxvector (fxvector 1 2 3)))
    (fxvector-set! v 0 0) => exception: not mutable


### 7.7. 字节向量 (Bytevectors)

如同向量， *Chez Scheme* 也扩展了字节向量的句法，以允许在 `#` 和左括号之间指定向量的长度，例如， `#3vu8(1 105 73).` 如果在此语法形式下提供的向量元素比指定的长度要少，则之后的每个元素都与最后一个提供的元素相同。读取器若遇到 `#!r6rs` ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 `#!chezscheme`.

*Chez Scheme* 同时扩展了字节向量的基本操作集，包括了加载和存储 3, 5, 6, 7 字节长度的基本操作。

*Chez Scheme* 中，字节向量的长度和索引总是定长数。

字节向量默认是可变的，包括常量。程序可以通过 `bytevector->immutable-bytevector` 创建不可变字节向量。尝试修改不可变字节向量会导致抛出异常。

过程: (bytevector fill &#x2026;)

返回: 一个内容为 `fill ...` 的字节向量

库: (chezscheme)

每个填充值必须为一个表示 8 位有符号或无符号值的精确整数，即，一个在范围 -128 至 255（两端均包含）之间的值。负的填充值被视为与其等价的补码。

    (bytevector) => #vu8()
    (bytevector 1 3 5) => #vu8(1 3 5)
    (bytevector -1 -3 -5) => #vu8(255 253 251)

过程: (bytevector->s8-list bytevector)

返回: `bytevector` 转化成的 8 位有符号数列表

库: (chezscheme)

返回列表中的值均为精确的 8 位有符号整数，即，在范围 -128 至 127（两端均包含）之间的值。 `bytevector->s8-list` 与第 6 修订版中的 `bytevector->u8-list` 相似，只是返回列表中的值是有符号数，而非无符号数。

    (bytevector->s8-list (make-bytevector 0)) => ()
    (bytevector->s8-list #vu8(1 127 128 255)) => (1 127 -128 -1)

    (let ([v #vu8(1 2 3 255)])
      (apply * (bytevector->s8-list v))) => -6

过程: (s8-list->bytevector list)

返回: `list` 中的元素组成的新字节向量

库: (chezscheme)

`list` 必须完全由精确的 8 位有符号整数组成，即，在范围 -128 至 127（两端均包含）之间的值。 `s8-list->bytevector` 与第 6 修订版中的过程 `u8-list->bytevector` 相似，只是输入列表中的元素是有符号数，而非无符号数。

    (s8-list->bytevector '()) => #vu8()
    (s8-list->bytevector '(1 127 -128 -1)) => #vu8(1 127 128 255)

    (let ([v #vu8(1 2 3 4 5)])
      (let ([ls (bytevector->s8-list v)])
        (s8-list->bytevector (map - ls)))) => #vu8(255 254 253 252 251)

过程: (bytevector-truncate! bytevector n)

返回: `bytevector`, 或空字节向量

库: (chezscheme)

`bytevector` 必须是可变的。 `n` 必须是一个精确的非负定长数，且不大于 `bytevector` 的长度。如果 `n` 是 0, `bytevector-truncate!` 返回空字节向量，否则， `bytevector-truncate!` 破坏性地把 `bytevector` 缩短为其前 `n` 个字节，并返回 `bytevector`.

    (define bv (make-bytevector 7 19))
    (bytevector-truncate! bv 0) => #vu8()
    bv => #vu8(19 19 19 19 19 19 19)
    (bytevector-truncate! bv 3) => #vu8(19 19 19)
    bv => #vu8(19 19 19)

过程: (bytevector-u24-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 24 位无符号整数

过程: (bytevector-s24-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 24 位有符号整数

过程: (bytevector-u40-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 40 位无符号整数

过程: (bytevector-s40-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 40 位有符号整数

过程: (bytevector-u48-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 48 位无符号整数

过程: (bytevector-s48-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 48 位有符号整数

过程: (bytevector-u56-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 56 位无符号整数

过程: (bytevector-s56-ref bytevector n eness)

返回: `bytevector` 的索引 `n` (始于 0) 处的 56 位有符号整数

库: (chezscheme)

`n` 必须是一个精确的非负整数，并且指示数值的起始字节。 `n` 和数值占用的字节之和 (24 位数值为 3 个字节，40 位数值为 5 个字节，48 位数值为 6 个字节，56 位数值为 7 个字节) 一定不能超过 `bytevector` 的长度。 `eness` 必须是一个命名此字节序(endianness)的有效的字节序符号(symbol)。

返回值是一个精确整数，根据数值所占用的字节数处于适当的区间。有符号数是作为其补码存储的等价值。

过程: (bytevector-u24-set! bytevector n u24 eness)

过程: (bytevector-s24-set! bytevector n s24 eness)

过程: (bytevector-u40-set! bytevector n u40 eness)

过程: (bytevector-s40-set! bytevector n s40 eness)

过程: (bytevector-u48-set! bytevector n u48 eness)

过程: (bytevector-s48-set! bytevector n s48 eness)

过程: (bytevector-u56-set! bytevector n u56 eness)

过程: (bytevector-s56-set! bytevector n s56 eness)

返回: 未定义

库: (chezscheme)

`bytevector` 必须是不可变的。 `n` 必须是一个精确的非负整数，并且指示数值的起始字节。 `n` 和数值占用的字节之和一定不能超过 `bytevector` 的长度。 `u24` 必须是一个 24 位无符号值，即，在 0 至 2<sup>24</sup> - 1 (两端均包含) 区间中的值； `s24` 必须是一个 24 位有符号值，即，在 -2<sup>23</sup> 至 2<sup>23</sup> - 1 (两端均包含) 区间中的值； `u40` 必须是一个 40 位无符号值，即，在 0 至 2<sup>40</sup> - 1 (两端均包含) 区间中的值； `s40` 必须是一个 40 位有符号值，即，在 -2<sup>39</sup> 至 2<sup>39</sup> - 1 (两端均包含) 区间中的值； `u48` 必须是一个 48 位无符号值，即，在 0 至 2<sup>48</sup> - 1 (两端均包含) 区间中的值； `s48` 必须是一个 48 位有符号值，即，在 -2<sup>47</sup> 至 2<sup>47</sup> - 1 (两端均包含) 区间中的值； `u56` 必须是一个 56 位无符号值，即，在 0 至 2<sup>56</sup> - 1 (两端均包含) 区间中的值； `s56` 必须是一个 56 位有符号值，即，在 -2<sup>55</sup> 至 2<sup>55</sup> - 1 (两端均包含) 区间中的值。 `eness` 必须是一个命名此字节序(endianness)的有效的字节序符号(symbol)。

这些过程把给定值存储到 `bytevector` 的索引 `n` (基于 0)处起始的 3, 5, 6, 7 字节中。负值存储为与其等价的补码。

过程: (mutable-bytevector? obj)

返回: 如果 `obj` 是一个可变的字节向量，则为 `#t`, 否则为 `#f`.

过程: (immutable-bytevector? obj)

返回: 如果 `obj` 是一个不可变的字节向量，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (mutable-bytevector? (bytevector 1 2 3)) => #t
    (mutable-bytevector?
     (bytevector->immutable-bytevector (bytevector 1 2 3))) => #f
    (immutable-bytevector? (bytevector 1 2 3)) => #f
    (immutable-bytevector?
     (bytevector->immutable-bytevector (bytevector 1 2 3))) => #t
    (immutable-bytevector? (cons 3 4)) => #f

过程: (bytevector->immutable-bytevector bytevector)

返回: 与 `bytevector` 相等(equal)的一个不可变字节向量

库: (chezscheme)

如果 `bytevector` 是不可变的，则结果为其本身；否则，结果是与 `bytevector` 内容相同的一个不可变字节向量。

    (define bv (bytevector->immutable-bytevector (bytevector 1 2 3)))
    (bytevector-u8-set! bv 0 0) => exception: not mutable

过程: (bytevector-compress bytevector)

返回: 一个新的字节向量，包含 `bytevector` 压缩后的内容

库: (chezscheme)

结果是原始的压缩数据，以最精简的头部信息记录了压缩前的大小和压缩模式。结果并未包含使用压缩选项通过 *port-based* 压缩所写入的头部信息。

过程: (bytevector-uncompress bytevector)

返回: 一个字节向量，包含 `bytevector` 解压缩后的内容

库: (chezscheme)

把一个由 `bytevector-compress` 生成的 `bytevector`, 解压为一个新的字节向量，其内容与最初传递给 `bytevector-compress` 的 字节向量相同。


### 7.8. Boxes

*Boxes* 是一种单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 *boxes* 实现 `call-by-reference` 的语义。

*Boxes* 的字面形式带有前缀 `#&` (发音为 "hash-ampersand"). 例如， `#&(a b c)` 是一个 *box，内容为列表* `(a b c)`. 读取器若遇到 `#!r6rs` ，则会在其后的输入流中禁用 *box* 句法，除非在更近的位置遇到 `#!chezscheme`.

所有 *boxes* 默认是可变的，包括常量。程序可以通过 `box-immutable` 创建不可变 *boxes*. 尝试修改不可变 *box* 会导致抛出异常。

过程: (box? obj)

返回: 如果 `obj` 是 *box*, 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (box? '#&a) => #t
    (box? 'a) => #f
    (box? (box 3)) => #t

过程: (box obj)

返回: 一个包含 `obj` 的新的 *box*

库: (chezscheme)

    (box 'a) => #&a
    (box (box '(a b c))) => #&#&(a b c)

过程: (unbox box)

返回: `box` 的内容

库: (chezscheme)

    (unbox #&a) => a
    (unbox #&#&(a b c)) => #&(a b c)

    (let ([b (box "hi")])
      (unbox b)) => "hi"

过程: (set-box! box obj)

返回: 未定义

库: (chezscheme)

`box` 必须是可变的。 `set-box!` 把 `box` 的内容设置为 `obj`.

    (let ([b (box 'x)])
      (set-box! b 'y)
      b) => #&y

    (let ([incr!
           (lambda (x)
             (set-box! x (+ (unbox x) 1)))])
      (let ([b (box 3)])
        (incr! b)
        (unbox b))) => 4

过程: (box-cas! box old-obj new-obj)

返回: 如果 `box` 被改变，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

`box` 必须是可变的。 若 `box` 待替换的内容和 `old-obj` 相同(基于 `eq?`), 则 `box-cas!` 自动将 `box` 的内容替换为 `new-obj`; 若不相同，则 `box` 保持不变。

    (define b (box 'old))
    (box-cas! b 'old 'new) => #t
    (unbox b) => 'new
    (box-cas! b 'other 'wrong) => #f
    (unbox b) => 'new

过程: (mutable-box? obj)

返回: 如果 `obj` 是可变的 *box* ，则为 `#t`, 否则为 `#f`.

过程: (immutable-box? obj)

返回: 如果 `obj` 是不可变的 *box* ，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (mutable-box? (box 1)) => #t
    (mutable-box? (box-immutable 1)) => #f
    (immutable-box? (box 1)) => #f
    (immutable-box? (box-immutable 1)) => #t
    (mutable-box? (cons 3 4)) => #f

过程: (box-immutable obj)

返回: 一个内容为 `obj` 的新的不可变 *box*

库: (chezscheme)

*Boxes* 通常用来支持共享的，可变的结构，所以不可变的 *box* 一般没什么用。

    (define b (box-immutable 1))
    (set-box! b 0) => exception: not mutable


### 7.9. 符号 (Symbols)

*Chez Scheme* 对标准符号句法进行了多方面的扩展：

符号名可以以 `@` 开始，但是， `,@abc` 被解析为 `(unquote-splicing abc)`; 如果要生成 `(unquote @abc)` ，可以键入 `, @abc`, `\x40;abc`, 或者 `,|@abc|`.

单字符 `{` 和 `}` 被读取为符号。

通常作为数字起始的任意字符，可以作为符号名的开头，包括数字， `.`, `+`, `-`, 只要此字符和其后的字符序列总体不会被解析成一个数字就可以。

名字包含任意字符的符号可以通过转义符 `\` 或 `|` 来书写。 `\` 用来转义单个字符（除了 'x'，因为 `\x` 是 16 进制数的起始标记），而 `|` 用来转义一组字符，直到配对的 `|` 为止。

打印器总是依标准 R6RS 句法打印符号，所以，如 `@abc` 会被打印为 `\x40;abc`, `1-` 会被打印为 `\x31;-`.

`gensym` 过程族把“美观”版和“唯一”版名字放到 `#{` 和 `}` 之间打印出来，形如 `#{g1426 e5g1c94g642dssw-a}`. 它们也可以以前缀 `#:` 来只打印美观版名字，如 `#:g1426`.

读取器若遇到 `#!r6rs` ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 `#!chezscheme`.

过程: (gensym)

过程: (gensym pretty-name)

过程: (gensym pretty-name unique-name)

返回: 一个唯一生成的符号

库: (chezscheme)

每个 `gensym` 调用返回一个唯一生成的符号，即 *生成符号* 。每个生成的符号有两个名字：一个“美观”版名字和一个“唯一”版名字。

在上文的第一个形式中，美观名字是通过组合一个内部的前缀和一个内部计数器的值来形成（惰性的──参见下文）。在每个名字形成之后，内部计数器会增加。下文将提及的参数 `gensym-prefix` 和 `gensym-count`, 可以用来访问和设置内部前缀和计数器。前缀默认为单字符字符串 `"g".` 在第二和第三种形式中，新的生成符号的美观名字是 `pretty-name`, 其必须为一字符串。生成符号的美观名字由过程 `symbol->string` 返回。

在前两种形式中，唯一名字是一个自动生成的全局唯一名字。全局唯一名字是通过组合一个全局唯一标识符和一个内部计数器来构造的（惰性的──参见下文）。在第三种生成符号的形式中，新生成符号的唯一名字是 `unique-name`, 其必须为一字符串。生成符号的唯一名字可以通过过程 `gensym->unique-string` 获得。

唯一名字使得生成符号的字面形式可以被读回及在输入端可靠地一般化。生成符号的句法包括美观名字和唯一名字，如下面的例子所示：

    (gensym) => #{g0 bcsfg5eq4e9b3h9o-a}

当环境参数 `print-gensym` 被设为 `pretty`, 则打印器只输出美观名字，使用 `#:` 句法，所以

    (parameterize ([print-gensym 'pretty])
      (write (gensym)))

输出 `#:g0`.

当读取器遇到 `#:` 句法，便以其提供的美观名字产生一个生成符号，但是最初的唯一名字就遗失了。

当环境参数被设为 `#f`, 则打印器只输出美观名字，所以

    (parameterize ([print-gensym #f])
      (write (gensym)))

输出 `g0`. 只有在生成符号不需要再作为生成符号被读取回来时，这种做法才有益。

当生成符号被频繁创建，但很少被输出或存储在一个对象文件中时，为了减小构造和（线程）同步消耗，美观和唯一名字的生成是惰性的，即，直到第一次被打印器, *fasl writer*, 或显式地被过程 `symbol->string` 或 `gensym->unique-string` 请求时才创建。此外，在唯一名字被请求之前，生成符号不会被放入系统的驻留符号表（oblist; 参见第 156 页）。这使得一个生成符号可以在下列情况下被存储管理器回收：如果不存在对这个生成符号的引用，且不存在可访问的唯一名字，即使它有一个顶层绑定，或非空的属性列表。

    (define x (gensym))
    x                         => #{g2 bcsfg5eq4e9b3h9o-c}
    (symbol->string x)        => "g2"
    (gensym->unique-string x) => "bcsfg5eq4e9b3h9o-c"

生成符号包含之前版本 *Chez Scheme* 支持的非驻留符号 (uninterned symbols) 的概念。同样，谓词 `gensym?` 也取代了 `uninterned-symbol?`.

thread parameter: `gensym-prefix`

thread parameter: `gensym-count`

库: (chezscheme)

当 `gensym` 没有传入显式的字符串参数时，环境参数 `gensym-prefix` 和 `gensym-count` 被用来访问和设置生成美观名字的内部前缀和计数器。 `gensym-prefix` 默认为字符串 `"g"` , 并且可以被设置为任何对象。 `gensym-count` 起始于 0, 并且可以被设置为任何非负整数。

如上所述， *Chez Scheme* 把美观名字的创建延迟到其第一次被请求时──被打印器或通过显式调用 `symbol->string` 。在那之前，这些环境参数并不会起作用；因此，在调用 `gensym` 时设置它们，对生成的名字并没有影响。

    (let ([x (parameterize ([gensym-prefix "genny"]
                            [gensym-count 17]
                            [print-gensym 'pretty])
               (gensym))])
      (format "~s" x))                       => "#{g4 bcsfg5eq4e9b3h9o-e}"
    (let ([x (gensym)])
      (parameterize ([gensym-prefix "genny"]
                     [gensym-count 17]
                     [print-gensym #f])
        (format "~s" (gensym))))             => "genny17"

过程: (gensym->unique-string gensym)

返回: `gensym` 的唯一名字

库: (chezscheme)

    (gensym->unique-string (gensym)) => "bd3kufa7ypjcuvut-g"

过程: (gensym? obj)

返回: 如果 `obj` 是生成符号，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (gensym? (string->symbol "z")) => #f
    (gensym? (gensym "z")) => #t
    (gensym? 'a) => #f
    (gensym? 3) => #f
    (gensym? (gensym)) => #t
    (gensym? '#{g2 bcsfg5eq4e9b3h9o-c}) => #t

过程: (putprop symbol key value)

返回: 未定义

库: (chezscheme)

*Chez Scheme* 给每个符号关联一个属性列表，允许多个键值对直接和符号存储在一起。使用过程 `putprop` 和 `getprop`, 可以把新的键值对存入属性列表，或以类似关联列表的使用方式获取值。属性列表通常用来存储与符号自身相关的信息。比如，一个自然语言程序，可以使用符号来表示单词，利用它们的属性列表来存储有关用法和词意的信息。

`putprop` 在符号的属性列表中把键值关联起来。虽然键通常是符号，但键和值实际可以是任意类型的对象。

`putprop` 可以用来创建新属性，或改变已有属性。

参见 `getprop` 后面的例子。

过程: (getprop symbol key)

过程: (getprop symbol key default)

返回: `symbol` 属性列表中与 `key` 关联的值

库: (chezscheme)

`getprop` 在 `symbol` 的属性列表中搜索，寻找与 `key` 相同 (基于 `eq?`) 的键，如果存在，则返回与此键关联的值。如果在 `symbol` 的属性列表中，没有与 `key` 相关联的值， `getprop` 返回 `default`, 若没有提供 `default` 参数，则返回 `#f`.

    (putprop 'fred 'species 'snurd)
    (putprop 'fred 'age 4)
    (putprop 'fred 'colors '(black white))

    (getprop 'fred 'species) => snurd
    (getprop 'fred 'colors) => (black white)
    (getprop 'fred 'nonkey) => #f
    (getprop 'fred 'nonkey 'unknown) => unknown

    (putprop 'fred 'species #f)
    (getprop 'fred 'species 'unknown) => #f

过程: (remprop symbol key)

返回: 未定义

库: (chezscheme)

如果键 `key` 对应的属性存在，则 `remprop` 从 `symbol` 的属性列表中移除此属性。

    (putprop 'fred 'species 'snurd)
    (getprop 'fred 'species) => snurd

    (remprop 'fred 'species)
    (getprop 'fred 'species 'unknown) => unknown

过程: (property-list symbol)

返回: `symbol` 内部属性列表的一份拷贝

库: (chezscheme)

属性列表是一个键和值交替排列的列表，即， `(key value ...)`.

    (putprop 'fred 'species 'snurd)
    (putprop 'fred 'colors '(black white))
    (property-list 'fred) => (colors (black white) species snurd)

过程: (oblist)

返回: 驻留符号列表

库: (chezscheme)

系统维护着一份驻留符号表，以确保同一符号名在任意两处出现时会被解析为同一个符号对象。 `oblist` 过程返回当前处于此符号表中的符号列表。

当一个新的符号被引入系统，或一个生成符号（参见 152 页）的唯一名字被请求时，驻留符号列表变长。当垃圾收集器判断可以安全地丢弃一个符号时，列表缩短。可以安全丢弃一个符号的条件为：除了通过 `oblist`, 在别处均无法访问此符号，符号没有顶层绑定，属性列表中没有任何属性。

    (if (memq 'tiger (oblist)) 'yes 'no) => yes
    (equal? (oblist) (oblist)) => #t
    (= (length (oblist)) (length (oblist))) => #t or #f

上面的第一个例子体现了，所有驻留符号从它们被读取时即纳入驻留列表，早于被求值。第二个例子体现了，当对符号的引用存在时，没有符号可以从驻留列表中被移除，在当前情况下，即为对 `oblist` 的第一次调用（无论哪个调用先被执行）时返回的列表中的符号。第三个例子中的表达式，只有当垃圾收集发生在两次对 `oblist` 的调用之间时，且仅在这次收集从驻留列表中移除了一个或更多符号时，才会返回 `#f`.


### 7.10. Void

很多 Scheme 操作返回未定义结果。当一个操作的返回值为未定义时， *Chez Scheme* 通常返回一个特殊的 *void* 对象。 *Chez Scheme* 的 void 对象并不是要作为数据，因而也没有相应的读取器句法。就像没有读取器句法的其它对象，例如过程和端口， *Chez Scheme* 的输出过程以一种不可读的表示方式打印 void 对象，即， `#<void>`. 由于 void 对象应当只被那些并没有有意义的返回值的操作返回，所以默认的交互环境 (参见 `waiter-write`) 并不打印出 void 对象。 *Chez Scheme* 中返回 void 对象的操作有： `set!`, `set-car!`, `load`, and `write` 等等。

过程: (void)

返回: void 对象

库: (chezscheme)

`void` 是一个返回 void 对象的无参数过程。它可以用于强制那些只产生副作用的或值为未定义的表达式，使其求值为一个一致的，不重要的值。不过，由于多数 *Chez Scheme* 中用于副作用的操作本就返回 void 对象，所以几乎没有显式调用 `void` 过程的必要。

由于 void 对象用于显式地表示一个“未定义”值，所以不应当把它用作任何其它目的，或依赖于任何表达式会求值为 void 对象。

默认的交互环境输出会忽略 void 对象；即，值为 void 对象的表达式什么都不会打印出来。

    (eq? (void) #f) => #f
    (eq? (void) #t) => #f
    (eq? (void) '()) => #f


### 7.11. Sorting

过程: (sort predicate list)

过程: (sort! predicate list)

返回: `list` 中元素根据 `predicate` 排序后组成的列表

库: (chezscheme)

`sort` 和第 6 修订版中的 `list-sort` 是一样的，而 `sort!` 是 `sort` 的破坏性版本，即，它重用输入列表中的点对来构造输出列表。

    (sort < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)
    (sort! < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)

过程: (merge predicate list1 list2)

过程: (merge! predicate list1 list2)

返回: 依 `predicate` 指定的顺序融合 `list1` 和 `list2`.

库: (chezscheme)

`predicate` 应该是一个接收两个参数的过程，当它的第一个参数在融合后的列表中要排在第二个参数之前时返回 `#t`. 它不应有任何负作用。即，如果把 `predicate` 作用于两个对象 *x* 和 *y*, *x* 来自于第一个列表，而 *y* 来自于第二个列表，它应该只在 *x* 应在输出列表中排在 *y* 之前时返回 `#t`. 如果满足这个限制条件， `merge` 和 `merge!` 就是可靠的，其中来自 `list1` 的项在输出列表中排在来自 `list2` 的相等项的前面。融合后的列表中包含重复元素。

`merge!` 破坏性地组合列表，使用输入列表中的点对来构造输出列表。

    (merge char<?
           '(#\a #\c)
           '(#\b #\c #\d)) => (#\a #\b #\c #\c #\d)
    (merge <
           '(1/2 2/3 3/4)
           '(0.5 0.6 0.7)) => (1/2 0.5 0.6 2/3 0.7 3/4)


### 7.12. 哈希表 (Hashtables)

*Chez Scheme* 对 *hashtable* 机制进行了多方面的扩展，包括一种直接访问 *hashtable* 中键值对的方法，对 *weak(弱引用) eq hashtable* 和 *weak eqv hashtable* 的支持，及一些为 *eq hashtable* 和 *symbol hashtable* 定制的过程。

过程: (hashtable-cell hashtable key default)

返回: 一个点对 (参见下文)

库: (chezscheme)

`hashtable` 必须是一个 *hashtable*. `key` 和 `default` 可以是任意 Scheme 值。

如果 `hashtable` 中没有值与 `key` 相关联， `hashtable-cell` 修改 `hashtable` 以使 `key` 关联到 `default`. 它返回一个点对， *car* 是 `key`, *cdr* 是关联的值。改变这个点对的 cdr 字段，事实上会更改这个表，使 `key` 关联到一个新值。car 字段中的 `key` 是不应该被改动的。相对于第 6 修订版中的相应过程对 *hashtable* 条目的操作，这个过程的优势是，只通过一次 *hashtable* 查询，关联到一个键的值就可以被读写任意多次。

    (define ht (make-eq-hashtable))
    (define v (vector 'a 'b 'c))
    (define cell (hashtable-cell ht v 3))
    cell => (#(a b c) . 3)
    (hashtable-ref ht v 0) => 3
    (set-cdr! cell 4)
    (hashtable-ref ht v 0) => 4

过程: (hashtable-values hashtable)

返回: `hashtable` 中的值组成的向量

库: (chezscheme)

各值是 `hashtable` 中各个键的值。结果中未移除重复的值。返回向量中的值的顺序是不定的。

    (define ht (make-eq-hashtable))
    (define p1 (cons 'a 'b))
    (define p2 (cons 'a 'b))
    (hashtable-set! ht p1 "one")
    (hashtable-set! ht p2 "two")
    (hashtable-set! ht 'q "two")
    (hashtable-values ht) => #("one" "two" "two")

这个过程等价于：

    (lambda (ht)
      (let-values ([(keys values) (hashtable-entries ht)])
        values))

但更高效，因为那个键向量并不需要被创建。

过程: (make-weak-eq-hashtable)

过程: (make-weak-eq-hashtable size)

过程: (make-weak-eqv-hashtable)

过程: (make-weak-eqv-hashtable size)

返回: 一个新的 *weak eq hashtable*

库: (chezscheme)

这些过程与第 6 修订版中的过程 `make-eq-hashtable` 和 `make-eqv-hashtable` 是类似的，只是 *hashtable* 中的键是弱引用的，即，面对垃圾回收，它们并不受到保护。被垃圾收集器回收的键会从表中移除，而它们的关联值最晚会在下次表被修改时丢弃。

只要键没有被回收， *hashtable* 中的值就能被正常引用，因为键和值是使用弱引用点对(weak pair)配对在一起的。因此，如果 *hashtable* 中的一个值反向指回它自己的键，就会阻止垃圾收集器回收这个键。参见 `make-ephemeron-eq-hashtable` 和 `make-ephemeron-eqv-hashtable`.

通过 `hashtable-copy` 复制一个 *weak eq hashtable* 或 *weak eqv hashtable* 产生的拷贝也是弱引用的。如果此拷贝是不可变的，不可访问的键仍然可以从表中被丢弃，即使表中的内容在其它情况下是不变的。这种效果可以通过 `hashtable-keys` 和 `hashtable-entries` 来观察。

    (define ht1 (make-weak-eq-hashtable))
    (define ht2 (make-weak-eq-hashtable 32))

过程: (make-ephemeron-eq-hashtable)

过程: (make-ephemeron-eq-hashtable size)

过程: (make-ephemeron-eqv-hashtable)

过程: (make-ephemeron-eqv-hashtable size)

返回: 一个新的 *ephemeron eq hashtable*

库: (chezscheme)

这些过程类似于 `make-weak-eq-hashtable` 和 `make-weak-eqv-hashtable`, 但表中的值可以在（直接或间接）指向表中的键时，却不阻止垃圾收集器回收此键，因为键与值是通过 *ephemeron pairs* 配对的。

通过 `hashtable-copy` 复制一个 *ephemeron eq hashtable* 或 *ephemeron eqv hashtable* 产生的拷贝也是 *ephemeron table*. 一个不可访问的键从一个不可变的 *ephemeron hashtable* 中被丢弃的方式，和在不可变的 *weak hashtable* 中相同。

    (define ht1 (make-ephemeron-eq-hashtable))
    (define ht2 (make-ephemeron-eq-hashtable 32))

过程: (hashtable-weak? obj)

返回: 如果 `obj` 是 *weak eq hashtable* 或 *weak eqv hashtable*, 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (define ht1 (make-weak-eq-hashtable))
    (define ht2 (hashtable-copy ht1))
    (hashtable-weak? ht2) => #t

过程: (hashtable-ephemeron? obj)

返回: 如果 `obj` 是 *ephemeron eq hashtable* 或 *ephemeron eqv hashtable*, 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (define ht1 (make-ephemeron-eq-hashtable))
    (define ht2 (hashtable-copy ht1))
    (hashtable-ephemeron? ht2) => #t

过程: (eq-hashtable? obj)

返回: 如果 `obj` 是 *eq hashtable*, 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (eq-hashtable? (make-eq-hashtable)) => #t
    (eq-hashtable? '(not a hash table)) => #f

过程: (eq-hashtable-weak? hashtable)

返回: 如果 `hashtable` 是弱引用(weak)的，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

`hashtable` 必须是一个 *eq hashtable*.

    (eq-hashtable-weak? (make-eq-hashtable)) => #f
    (eq-hashtable-weak? (make-weak-eq-hashtable)) => #t

过程: (eq-hashtable-ephemeron? hashtable)

返回: 如果 `hashtable` 使用 *ephemeron pairs*, 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

`hashtable` 必须是 *eq hashtable*.

    (eq-hashtable-ephemeron? (make-eq-hashtable)) => #f
    (eq-hashtable-ephemeron? (make-ephemeron-eq-hashtable)) => #t

过程: (eq-hashtable-set! hashtable key value)

返回: 未定义

库: (chezscheme)

*hashtable* 必须是一个可变的 *eq hashtable*. `key` 和 `value` 可以是任何 scheme 值。

`eq-hashtable-set!` 在 `hashtable` 中把值 `value` 和键 `key` 关联起来。

    (define ht (make-eq-hashtable))
    (eq-hashtable-set! ht 'a 73)

过程: (eq-hashtable-ref hashtable key default)

返回: 参见下文

库: (chezscheme)

`hashtable` 必须是一个 *eq hashtable*. `key` 和 `default` 可以是任何 scheme 值。

`eq-hashtable-ref` 返回 `hashtable` 中和 `key` 关联的值。如果在 `hashtable` 中没有值和 `key` 相关联，则 `eq-hashtable-ref` 返回 `default`.

    (define ht (make-eq-hashtable))
    (define p1 (cons 'a 'b))
    (define p2 (cons 'a 'b))
    (eq-hashtable-set! ht p1 73)
    (eq-hashtable-ref ht p1 55) => 73
    (eq-hashtable-ref ht p2 55) => 55

过程: (eq-hashtable-contains? hashtable key)

返回: 如果在 `hashtable` 中 `key` 有关联值，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

`hashtable` 必须是一个 *eq hashtable*. `key` 可以是任何 scheme 值。

    (define ht (make-eq-hashtable))
    (define p1 (cons 'a 'b))
    (define p2 (cons 'a 'b))
    (eq-hashtable-set! ht p1 73)
    (eq-hashtable-contains? ht p1) => #t
    (eq-hashtable-contains? ht p2) => #f

过程: (eq-hashtable-update! hashtable key procedure default)

返回: 未定义

库: (chezscheme)

`hashtable` 必须是一个可变的 *eq hashtable*. `key` 和 `default` 可以是任何 scheme 值。 `procedure` 应该接受一个参数，返回一个值，并且不应当修改 `hashtable`.

`eq-hashtable-update!` 把 `procedure` 应用于 `hashtable` 中 `key` 关联的值上，如果 `key` 没有关联值，则应用于 `default`. 如果 `procedure` 正常返回，则 `eq-hashtable-update!` 把 `procedure` 返回的值关联到 `key` 上，如果旧的关联存在，则取代旧的关联。

一个不检查所接收参数是否是正确类型的 `eq-hashtable-update!` 版本可依如下定义。

    (define eq-hashtable-update!
      (lambda (ht key proc value)
        (eq-hashtable-set! ht key
                           (proc (eq-hashtable-ref ht key value)))))

一个可以避免多次哈希计算和哈希查找的更高效的 `eq-hashtable-update!` 实现如下：

    (define ht (make-eq-hashtable))
    (eq-hashtable-update! ht 'a
                          (lambda (x) (* x 2))
                          55)
    (eq-hashtable-ref ht 'a 0) => 110
    (eq-hashtable-update! ht 'a
                          (lambda (x) (* x 2))
                          0)
    (eq-hashtable-ref ht 'a 0) => 220

过程: (eq-hashtable-cell hashtable key default)

返回: 一个点对（参见下文）

库: (chezscheme)

`hashtable` 必须是一个 *eq hashtable*. `key` 和 `default` 可以是任何 scheme 值。

如果在 `hashtable` 中没有值与 `key` 相关联， `eq-hashtable-cell` 修改 `hashtable`, 把 `default` 关联到 `key`. 它返回一个点对，其 car 是 `key`, 而 cdr 是 `key` 关联的值。改变这个点对的 cdr 字段，事实上会更改这个表，使 `key` 关联到一个新值。 `key` 是不应该被改动的。

    (define ht (make-eq-hashtable))
    (define v (vector 'a 'b 'c))
    (define cell (eq-hashtable-cell ht v 3))
    cell => (#(a b c) . 3)
    (eq-hashtable-ref ht v 0) => 3
    (set-cdr! cell 4)
    (eq-hashtable-ref ht v 0) => 4

过程: (eq-hashtable-delete! hashtable key)

返回: 未定义

库: (chezscheme)

`hashtable` 必须是一个不可变的 *eq hashtable*. `key` 可以是任何 scheme 值。

`eq-hashtable-delete!` 会删除 `key` 在 `hashtable` 中的任何关联。

    (define ht (make-eq-hashtable))
    (define p1 (cons 'a 'b))
    (define p2 (cons 'a 'b))
    (eq-hashtable-set! ht p1 73)
    (eq-hashtable-contains? ht p1) => #t
    (eq-hashtable-delete! ht p1)
    (eq-hashtable-contains? ht p1) => #f
    (eq-hashtable-contains? ht p2) => #f
    (eq-hashtable-delete! ht p2)

过程: (symbol-hashtable? obj)

返回: 如果 `obj` 是 *symbol hashtable*, 则为 `#t`, 否则为 `#f`.

库: (chezscheme)

    (symbol-hashtable? (make-hashtable symbol-hash eq?)) => #t
    (symbol-hashtable? (make-eq-hashtable)) => #f

过程: (symbol-hashtable-set! hashtable key value)

返回: 未定义

库: (chezscheme)

`hashtable` 必须是一个可变的 *symbol hashtable*. (*symbol hashtable* 是通过哈希函数 `symbol-hash` 和相等性函数 `eq?`, `eqv?`, `equal?`, 或 `symbol=?` 创建的 `hashtable`.) `key` 必须是一个符号， `value` 可以是任何 scheme 值。

`symbol-hashtable-set!` 把 `hashtable` 中的键 `key` 和值 `value` 关联起来。

    (define ht (make-hashtable symbol-hash eq?))
    (symbol-hashtable-ref ht 'a #f) => #f
    (symbol-hashtable-set! ht 'a 73)
    (symbol-hashtable-ref ht 'a #f) => 73

过程: (symbol-hashtable-ref hashtable key default)

返回: 参见下文

库: (chezscheme)

`hashtable` 必须是一个 *symbol hashtable*. (*symbol hashtable* 是通过哈希函数 `symbol-hash` 和相等性函数 `eq?`, `eqv?`, `equal?`, 或 `symbol=?` 创建的 `hashtable`.) `key` 必须是一个符号， `default` 可以是任何 scheme 值。

`symbol-hashtable-ref` 返回 `hashtable` 中与 key 关联的值。如果 `hashtable` 中没有值与 `key` 相关联，则 `symbol-hashtable-ref` 返回 `default`.

    (define ht (make-hashtable symbol-hash eq?))
    (define k1 'abcd)
    (define k2 'not-abcd)
    (symbol-hashtable-set! ht k1 "hi")
    (symbol-hashtable-ref ht k1 "bye") => "hi"
    (symbol-hashtable-ref ht k2 "bye") => "bye"

过程: (symbol-hashtable-contains? hashtable key)

返回: 如果在 `hashtable` 中 `key` 存在关联值，则为 `#t`, 否则为 `#f`.

库: (chezscheme)

`hashtable` 必须是一个 *symbol hashtable*. (*symbol hashtable* 是通过哈希函数 `symbol-hash` 和相等性函数 `eq?`, `eqv?`, `equal?`, 或 `symbol=?` 创建的 `hashtable`.) `key` 必须是一个符号。

    (define ht (make-hashtable symbol-hash eq?))
    (define k1 'abcd)
    (define k2 'not-abcd)
    (symbol-hashtable-set! ht k1 "hi")
    (symbol-hashtable-contains? ht k1) => #t
    (symbol-hashtable-contains? ht k2 ) => #f

过程: (symbol-hashtable-update! hashtable key procedure default)

返回: 未定义

库: (chezscheme)

`hashtable` 必须是一个可变的 *symbol hashtable*. (*symbol hashtable* 是通过哈希函数 `symbol-hash` 和相等性函数 `eq?`, `eqv?`, `equal?`, 或 `symbol=?` 创建的 `hashtable`.) `key` 必须是一个符号， `default` 可以是任何 Scheme 值。 `procedure` 应该接受一个参数，返回一个值，且不应修改 `hashtable`.

`symbol-hashtable-update!` 把 `procedure` 应用于 `hashtable` 中 `key` 关联的值上，如果 `key` 没有关联值，则应用于 `default`. 如果 `procedure` 正常返回，则 `symbol-hashtable-update!` 把 `procedure` 返回的值关联到 `key` 上，如果旧的关联存在，则取代旧的关联。

一个不检查所接收参数是否是正确类型的 `symbol-hashtable-update!` 版本可依如下定义。

    (define symbol-hashtable-update!
      (lambda (ht key proc value)
        (symbol-hashtable-set! ht key
                               (proc (symbol-hashtable-ref ht key value)))))

一个可以避免多次哈希计算和哈希查找的更高效的 `symbol-hashtable-update!` 实现如下：

    (define ht (make-hashtable symbol-hash eq?))
    (symbol-hashtable-update! ht 'a
                              (lambda (x) (* x 2))
                              55)
    (symbol-hashtable-ref ht 'a 0) => 110
    (symbol-hashtable-update! ht 'a
                              (lambda (x) (* x 2))
                              0)
    (symbol-hashtable-ref ht 'a 0) => 220

过程: (symbol-hashtable-cell hashtable key default)

返回: 一个点对（参见下文）

库: (chezscheme)

`hashtable` 必须是一个可变的 *symbol hashtable*. (*symbol hashtable* 是通过哈希函数 `symbol-hash` 和相等性函数 `eq?`, `eqv?`, `equal?`, 或 `symbol=?` 创建的 `hashtable`.) `key` 必须是一个符号， `default` 可以是任何 Scheme 值。

如果在 `hashtable` 中没有值与 `key` 相关联， `symbol-hashtable-cell` 修改 `hashtable`, 把 `default` 关联到 `key`. 它返回一个点对，其 car 是 `key`, 而 cdr 是 `key` 关联的值。改变这个点对的 cdr 字段，事实上会更改这个表，使 `key` 关联到一个新值。 `key` 是不应该被改动的。

    (define ht (make-hashtable symbol-hash eq?))
    (define k 'a-key)
    (define cell (symbol-hashtable-cell ht k 3))
    cell => (a-key . 3)
    (symbol-hashtable-ref ht k 0) => 3
    (set-cdr! cell 4)
    (symbol-hashtable-ref ht k 0) => 4

过程: (symbol-hashtable-delete! hashtable key)

返回: 未定义

库: (chezscheme)

`hashtable` 必须是一个可变的 *symbol hashtable*. (*symbol hashtable* 是通过哈希函数 `symbol-hash` 和相等性函数 `eq?`, `eqv?`, `equal?`, 或 `symbol=?` 创建的 `hashtable`.) `key` 必须是一个符号。

`symbol-hashtable-delete!` 从 `hashtable` 中删除 `key` 的任何关联值。

    (define ht (make-hashtable symbol-hash eq?))
    (define k1 (gensym))
    (define k2 (gensym))
    (symbol-hashtable-set! ht k1 73)
    (symbol-hashtable-contains? ht k1) => #t
    (symbol-hashtable-delete! ht k1)
    (symbol-hashtable-contains? ht k1) => #f
    (symbol-hashtable-contains? ht k2) => #f
    (symbol-hashtable-delete! ht k2)
